title: About languages and tools: the walking dead and other legends
date: 2025-05-08 13:00
tags: languages, development, tools, rant, technology 
summary: About stability and death of languages and tools
---

I'm writing this post to react to one of the many articles and threads about the
presumed death of this or that programming language, library, framework, or
tool. What that article was about and who wrote it is secondary. I could
synthesize my idea by citing a well-known joke by Mark Twain: "The rumors about
my death are greatly exaggerated."

Let me use a _synecdoche_ rhetorical expedient and limit what follows to
programming languages. Of course, this post is not absolutely limited to them;
it could be applied with little effort to libraries, tools, frameworks, content
management systems, and many other tools of common use among developers.

Any developer who has been around enough knows that the death hoaxes about the
end of a programming language are a common refrain that returns almost every
year for most of them. The nude truth about programming languages is that
developers follow trends and fashions. Job recruitments influence such trends,
as well as some application categories and technologies that appear from time to
time.  Without any specific preference, there are currently tons of languages
that still have significant (or even not so large, but still sustainable)
communities that passed in the rearguard because their trendy momentum has been
in the past. A lot of people mistake the end of convulse development periods
(or, even worse, the absence of headlines on major tech news sites) for death. I
could cite many such products that were considered dead a long time ago and
still see one or more releases per year. From stability to death, it is often a
matter of points of view.

I would not refer to Fortran, Cobol, Ada, Prolog, Lisp, etc., which have been
around for 60-70 years. For me, all those are clearly niche languages that still
have their own use in specific domains, and that has been true at least in the
last 40 or 50 years. In most cases, they are not simply updated for features or
even able to manage common applications or programming patterns of the modern
era.

Who would try to write a web framework in Fortran or Cobol? Oh well, you
probably don't know  [Fortran.io](https://fortran.io/), 
an MVC web framework written in Fortran90. Or even any of the full-stack web
framework written in Cobol. 
So, it is better to say that for such languages, some applications are purely
intellectual challenges, drafts, and sketches that no one would seriously(?)
consider in production environments. That does not imply that such products are
at a dead end, but only that they are not considered for those applications (but
could be for other ones).

But for them, there are even more recent languages that gained the stage about
20-30 years ago or less, such as Java, Perl, Ruby, or PHP, which are still in
use in production environments but in declining popularity. A special case is
C/C++ and its variants, which most consider low-level languages at a dead-end
but are actively used in many application domains. Today, Rust is considered by
general rumors to be their natural replacement, but again, there is no evidence
that it will truly be so in the future. Often, in the past, what appeared to be
an ineluctable success in a certain period revealed a pure illusion to be
replaced by the next language of dreams.

So what? A dose of sane realism is genuinely required. Developers are voluble
and suffer from early love like teenagers. What today seems like the way to go
could only reveal a dazzle a few years (or even months) later. Being a bit
conservative could help, but the whole _silver bullet idea_ for tooling is
auto-lesionism. There is not one ring to rule them all. Simply, there is not a
single language to win in all fields, and the skill of being able to switch
comfortably among multiple ones (possibly finding the most helpful for a
specific goal or application domain) is the true superpower of a developer.
That's specifically true if such languages expose different programming patterns
and abstractions. All the rest is for gossip and opinions. Sometimes, a specific
package or framework declares the convenience of using the language (do you
remember the whole Ruby-on-Rails momentum?), as well as the existence of a very
specific language feature (e.g., Erlang efficiency in concurrency). That is the
true basis of a reasoned choice for an implementation.

That said, the only concrete problem nowadays is the job market. A learning plan
that includes only good-but-old, as well as for the opposite, only too recent
tools, could be equally wrong. The job opportunities could be equally few for
both. It seems that the most convenient language is one with a vast community,
but unfortunately, that could be a transient status: at the very beginning of
the third millennium, it seemed that Perl was the language of choice for web
applications, which became clearly not the case just a few years later. So what?
Well, a grain of salt is due in any case, but what seems like the current
primary choice could become a language of the past in just a few years.

A complete developer should at least know at a non-trivial level at least a
system programming language (e.g., C/C++, or Rust), as well as Python,
JavaScript, and possibly also a pure functional one (e.g, Scheme, Clojure, or
Haskell). Of course, moving from a non-trivial level to the guru level is a
matter of time and experience, and it could also never happen in practice for
each of them.

What will be the next dead language in the near future that still seems to be
the current Big Thing? I have some suspicions, but I keep them to myself.
